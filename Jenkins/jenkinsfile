pipeline {
    agent any

    environment {
        AWS_ACCOUNT_ID = '891377165332'
        AWS_REGION = 'eu-central-1'
        ECR_BACKEND_REPO_NAME = 'backend-repo'
        ECR_FRONTEND_REPO_NAME = 'frontend-repo'
        IMAGE_TAG = 'latest'
        TERRAFORM_DIR = 'Terraform'
    }

    stages {
        stage('Checkout Code') {
            steps {
                git branch: 'dev', url: 'https://github.com/DevCloud-Solutions/AI-Application.git'
            }
        }

        stage('Terraform Init') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform init'
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform plan -out=tfplan'
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform apply -auto-approve tfplan'
                }
            }
        }

        stage('Generate Dynamic Ansible Inventory') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    script {
                        def master_ip = sh(script: 'terraform output -raw master_public_ip', returnStdout: true).trim()
                        def workerone_ip = sh(script: 'terraform output -raw workerone_public_ip', returnStdout: true).trim()
                        def workertwo_ip = sh(script: 'terraform output -raw workertwo_public_ip', returnStdout: true).trim()

                        // Ansible dizinine dinamik inventory yazmak için WORKSPACE yolunu kullan
                        def ansible_inventory_path = "${WORKSPACE}/Ansible/inventory/dynamic_inventory.py"

                        // Dinamik envanteri oluştur ve Ansible dizinine yaz
                        writeFile file: ansible_inventory_path, text: """
#!/usr/bin/env python3
import json

def get_inventory():
    inventory = {
        "master": {
            "hosts": ["${master_ip}"],
            "vars": {
                "ansible_user": "ec2-user"
            }
        },
        "workers": {
            "hosts": ["${workerone_ip}", "${workertwo_ip}"],
            "vars": {
                "ansible_user": "ec2-user"
            }
        }
    }
    print(json.dumps(inventory))

if __name__ == "__main__":
    get_inventory()
"""
                        sh 'chmod +x dynamic_inventory.py'
                    }
                }
            }
        }

        stage('Run Ansible Playbooks') {
    steps {
        sshagent(credentials: ['EC2-SSH-Key']) { // EC2-SSH-Key, Jenkins Global Credentials ID
            dir("${TERRAFORM_DIR}") {
                script {
                    // Dinamik envanter dosyasının doğru yolunu kullanıyoruz
                    def ansible_inventory_path = "${WORKSPACE}/Ansible/inventory/dynamic_inventory.py"

                    // Ansible playbooklarını çalıştırıyoruz
                    sh "ansible-playbook -i ${ansible_inventory_path} Ansible/playbooks/master_setup.yml"
                    sh "ansible-playbook -i ${ansible_inventory_path} Ansible/playbooks/worker_setup.yml"
                }
            }
        }
    }
}


        stage('Approve Destroy') {
            steps {
                script {
                    def destroyApproval = input message: 'Tüm altyapıyı silmek istediğinize emin misiniz?', ok: 'Evet, Sil', parameters: [
                        choice(name: 'ConfirmDestroy', choices: ['Hayır', 'Evet'], description: 'Devam etmek istiyor musunuz?')
                    ]
                    if (destroyApproval != 'Evet') {
                        error("Destroy işlemi iptal edildi.")
                    }
                }
            }
        }

        stage('Terraform Destroy') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform destroy -auto-approve'
                }
            }
        }
    }
}

    
//         stage('Build Backend Docker Image') {
//             steps {
//                 script {
//                     sh 'docker build -t ${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG} -f backend/Dockerfile .'
//                 }
//             }
//         }

//         stage('Build Frontend Docker Image') {
//             steps {
//                 script {
//                     sh 'docker build -t ${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG} -f frontend/Dockerfile .'
//                 }
//             }
//         }

//         stage('Login to AWS ECR') {
//             steps {
//                 script {
//                     sh 'aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com'
//                 }
//             }
//         }

//         stage('Tag and Push Docker Images to ECR') {
//             steps {
//                 script {
//                     sh 'docker tag ${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG} ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG}'
//                     sh 'docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG}'

//                     sh 'docker tag ${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG} ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG}'
//                     sh 'docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG}'
//                 }
//             }
//         }

//         stage('Deploy to Kubernetes') {
//             steps {
//                 script {
//                     sh 'kubectl set image deployment/backend-deployment backend=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG}'
//                     sh 'kubectl set image deployment/frontend-deployment frontend=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG}'
//                 }
//             }
//         }

//         stage('Terraform Destroy on Failure') {
//             when {
//                 expression {
//                     currentBuild.result == 'FAILURE'
//                 }
//             }
//             steps {
//                 dir("${TERRAFORM_DIR}") {
//                     script {
//                         sh 'terraform destroy -auto-approve'
//                     }
//                 }
//             }
//         }
//     }

//     post {
//         always {
//             cleanWs()
//         }
//     }
// }

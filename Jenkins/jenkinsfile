pipeline {
    agent any

    environment {
        AWS_ACCOUNT_ID = '891377165332'
        AWS_REGION = 'eu-central-1'
        ECR_BACKEND_REPO_NAME = 'backend-repo'
        ECR_FRONTEND_REPO_NAME = 'frontend-repo'
        IMAGE_TAG = 'latest'
        ANSIBLE_INVENTORY = 'inventory'
        TERRAFORM_DIR = 'Terraform'
    }

    stages {
        stage('Checkout Code') {
            steps {
                git branch: 'dev', url: 'https://github.com/DevCloud-Solutions/AI-Application.git'
            }
        }

        stage('Terraform Init') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform init'
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform plan -out=tfplan'
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform apply -auto-approve tfplan'
                }
            }
        }

        
        stage('Generate Ansible Inventory') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    script {
                        def master_ip = sh(script: 'terraform output -raw master_public_ip', returnStdout: true).trim()
                        def workerone_ip = sh(script: 'terraform output -raw workerone_public_ip', returnStdout: true).trim()
                        def workertwo_ip = sh(script: 'terraform output -raw workertwo_public_ip', returnStdout: true).trim()

                        writeFile file: 'inventory', text: """
[master]
${master_ip} ansible_user=ec2-user

[workers]
${workerone_ip} ansible_user=ec2-user
${workertwo_ip} ansible_user=ec2-user
"""
                    }
                }
            }
        }

        stage('Run Ansible Playbooks') {
            steps {
                sshagent(credentials: ['EC2-SSH-Key']) { // EC2-SSH-Key, Jenkins Global Credentials ID'si
                    script {
                        sh 'ansible-playbook -i ${ANSIBLE_INVENTORY} Ansible/playbooks/master_setup.yml'
                        sh 'ansible-playbook -i ${ANSIBLE_INVENTORY} Ansible/playbooks/worker_setup.yml'
                    }
                }
            }
        }
        stage('Approve Destroy') {
            steps {
                script {
                    // Kullanıcıdan onay almak için input bloğu
                    def destroyApproval = input message: 'Tüm altyapıyı silmek istediğinize emin misiniz?', ok: 'Evet, Sil', parameters: [
                        choice(name: 'ConfirmDestroy', choices: ['Hayır', 'Evet'], description: 'Devam etmek istiyor musunuz?')
                    ]
                    if (destroyApproval != 'Evet') {
                        error("Destroy işlemi iptal edildi.")
                    }
                }
            }
        }

        stage('Terraform Destroy') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform destroy -auto-approve'
                }
            }
        }
    }
}
    
//         stage('Build Backend Docker Image') {
//             steps {
//                 script {
//                     sh 'docker build -t ${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG} -f backend/Dockerfile .'
//                 }
//             }
//         }

//         stage('Build Frontend Docker Image') {
//             steps {
//                 script {
//                     sh 'docker build -t ${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG} -f frontend/Dockerfile .'
//                 }
//             }
//         }

//         stage('Login to AWS ECR') {
//             steps {
//                 script {
//                     sh 'aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com'
//                 }
//             }
//         }

//         stage('Tag and Push Docker Images to ECR') {
//             steps {
//                 script {
//                     sh 'docker tag ${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG} ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG}'
//                     sh 'docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG}'

//                     sh 'docker tag ${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG} ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG}'
//                     sh 'docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG}'
//                 }
//             }
//         }

//         stage('Deploy to Kubernetes') {
//             steps {
//                 script {
//                     sh 'kubectl set image deployment/backend-deployment backend=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG}'
//                     sh 'kubectl set image deployment/frontend-deployment frontend=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG}'
//                 }
//             }
//         }

//         stage('Terraform Destroy on Failure') {
//             when {
//                 expression {
//                     currentBuild.result == 'FAILURE'
//                 }
//             }
//             steps {
//                 dir("${TERRAFORM_DIR}") {
//                     script {
//                         sh 'terraform destroy -auto-approve'
//                     }
//                 }
//             }
//         }
//     }

//     post {
//         always {
//             cleanWs()
//         }
//     }
// }

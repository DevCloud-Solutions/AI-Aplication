pipeline {
    agent any

    environment {
        SSH_KEY_PATH = 'test.pem'  // Geçici SSH anahtar dosya yolu
        ANSIBLE_CFG_PATH = 'ansible.cfg'  // Ansible config dosyası
    }

    stages {
        stage('Checkout Terraform and Ansible Code') {
            steps {
                git branch: 'dev', url: 'https://github.com/DevCloud-Solutions/AI-Application.git'
            }
        }

        stage('Terraform Apply') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'SSH_KEY_FILE')]) {
                    sh '''
                        # SSH anahtarını geçici bir dosyaya yaz
                        echo "$SSH_KEY_FILE" > $SSH_KEY_PATH
                        chmod 400 $SSH_KEY_PATH

                        # Terraform çıktısını JSON olarak al
                        terraform output -json > inventory.json

                        # Python ile inventory.yaml oluştur
                        python3 -c "
import json

with open('inventory.json') as f:
    data = json.load(f)

master_ip = data.get('master_public_ip', {}).get('value')
workerone_ip = data.get('workerone_public_ip', {}).get('value')
workertwo_ip = data.get('workertwo_public_ip', {}).get('value')

if not master_ip:
    print('master_public_ip bulunamadı! Terraform çıktısını kontrol edin.')
    master_ip = '0.0.0.0'

worker_ips = [ip for ip in [workerone_ip, workertwo_ip] if ip]

inventory = {
    'master': {
        'hosts': [master_ip]
    },
    'workers': {
        'hosts': worker_ips
    }
}

with open('inventory.yaml', 'w') as f:
    f.write(json.dumps(inventory, indent=2))
"
                    '''
                }
            }
        }

        stage('Create Ansible Config') {
            steps {
                sh '''
                    cat <<EOF > $ANSIBLE_CFG_PATH
                    [defaults]
                    inventory = ./inventory.yaml
                    host_key_checking = False
                    private_key_file = $SSH_KEY_PATH
                    EOF
                '''
            }
        }

        stage('Ansible Master Setup') {
            steps {
                sh '''
                    ansible-playbook -i inventory.yaml /Ansible/playbooks/master_setup.yml \
                    --private-key $SSH_KEY_PATH
                '''
            }
        }

        stage('Ansible Worker Setup') {
            steps {
                sh '''
                    ansible-playbook -i inventory.yaml /Ansible/playbooks/worker_setup.yml \
                    --private-key $SSH_KEY_PATH
                '''
            }
        }
    }

    post {
        always {
            // Geçici dosyaları temizle
            sh 'rm -f $SSH_KEY_PATH $ANSIBLE_CFG_PATH inventory.yaml'
        }
    }
}




//         stage('Build and Push Docker Images') {
//             steps {
//                 script {
//                     sh '''
//                     docker build -t ${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG} -f backend/Dockerfile .
//                     docker build -t ${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG} -f frontend/Dockerfile .

//                     aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

//                     docker tag ${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG} ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG}
//                     docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_BACKEND_REPO_NAME}:${IMAGE_TAG}

//                     docker tag ${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG} ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG}
//                     docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_FRONTEND_REPO_NAME}:${IMAGE_TAG}
//                     '''
//                 }
//             }
//         }

//         stage('Deploy to Kubernetes') {
//             steps {
//                 script {
//                     withEnv(["KUBECONFIG=${KUBECONFIG_PATH}", "PATH=$PATH:/usr/local/bin"]) {
//                         sh '''
//                         echo "PATH: $PATH"  # PATH kontrolü
//                         echo "Kubeconfig path: $KUBECONFIG"  # Kubeconfig doğrulama
//                         kubectl version --client  # Kubectl erişimini kontrol et
//                         kubectl apply -f kubernetes/backend-deployment.yaml
//                         kubectl apply -f kubernetes/frontend-deployment.yaml
//                         kubectl rollout status deployment/backend-deployment
//                         kubectl rollout status deployment/frontend-deployment
//                         '''
//                     }
//                 }
//             }
//         }
//     }

//     post {
//         always {
//             cleanWs()  // İşlem tamamlandığında workspace temizlenir
//         }
//         failure {
//             dir("${TERRAFORM_DIR}") {
//                 sh 'terraform destroy -auto-approve'  // Başarısızlık durumunda altyapı yok edilir
//             }
//         }
//     }
// }
